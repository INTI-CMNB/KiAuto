#!/usr/bin/env python3
"""Various pcbnew operations

This program runs eeschema and can:
1) Print PCB layers
2) Run the DRC
The process is graphical and very delicated.
"""

__author__ = 'Salvador E. Tropea'
__copyright__ = 'Copyright 2019-2020, INTI/Productize SPRL'
__credits__ = ['Salvador E. Tropea', 'Scott Bezek']
__license__ = 'Apache 2.0'
__email__ = 'salvador@inti.gob.ar'
__status__ = 'beta'

import sys
import os
import argparse
import atexit
import re
import shutil

import subprocess
import gettext

# Look for the 'kicad_auto' module from where the script is running
script_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, os.path.dirname(script_dir))
# Utils import
# Log functionality first
from kicad_auto import log
log.set_domain(os.path.splitext(os.path.basename(__file__))[0])
from kicad_auto import file_util
from kicad_auto.misc import (REC_W, REC_H, __version__, NO_PCB, PCBNEW_CFG_PRESENT, WAIT_START, WRONG_LAYER_NAME,
                             WRONG_PCB_NAME, PCBNEW_ERROR)
from kicad_auto.ui_automation import (
    PopenContext,
    xdotool,
    wait_not_focused,
    wait_for_window,
    recorded_xvfb,
    clipboard_store
)


def parse_drc(drc_file):
    with open(drc_file, 'r') as f:
        lines = f.read().splitlines()

    drc_errors = None
    unconnected_pads = None

    for line in lines:
        if drc_errors is not None and unconnected_pads is not None:
            break
        m = re.search(r'^\*\* Found ([0-9]+) DRC errors \*\*$', line)
        if m:
            drc_errors = m.group(1)
            continue
        m = re.search(r'^\*\* Found ([0-9]+) unconnected pads \*\*$', line)
        if m:
            unconnected_pads = m.group(1)
            continue

    return int(drc_errors), int(unconnected_pads)


def dismiss_already_running():
    # The "Confirmation" modal pops up if pcbnew is already running
    try:
        nf_title = 'Confirmation'
        wait_for_window(nf_title, nf_title, 1)

        logger.info('Dismiss pcbnew already running')
        xdotool(['search', '--onlyvisible', '--name', nf_title, 'windowfocus'])
        xdotool(['key', 'Return'])
    except RuntimeError:
        pass


def dismiss_warning():
    try:
        nf_title = 'Warning'
        wait_for_window(nf_title, nf_title, 1)

        logger.error('Dismiss pcbnew warning, will fail')
        xdotool(['search', '--onlyvisible', '--name', nf_title, 'windowfocus'])
        xdotool(['key', 'Return'])
    except RuntimeError:
        pass


def dismiss_error():
    try:
        nf_title = 'Error'
        wait_for_window(nf_title, nf_title, 1)

        logger.debug('Dismiss pcbnew error')
        xdotool(['search', '--onlyvisible', '--name', nf_title, 'windowfocus'])
        logger.debug('Found, sending Return')
        xdotool(['key', 'Return'])
        return True
    except RuntimeError:
        pass
    return False


def wait_for_pcbnew():
    failed_focuse = False
    try:
        wait_for_window('Main pcbnew window', 'Pcbnew', args.wait_start)
    except RuntimeError:
        logger.debug('Time-out waiting for pcbnew, will retry')
        failed_focuse = True
        pass
    if failed_focuse:
        if dismiss_error():
            logger.error('pcbnew reported an error')
            exit(PCBNEW_ERROR)
        dismiss_already_running()
        dismiss_warning()
        try:
            wait_for_window('Main pcbnew window', 'Pcbnew', 5)
        except RuntimeError:
            logger.error('Time-out waiting for pcbnew, giving up')
            raise


def print_layers(pcb_file, output_dir, output_filename, record=True):

    os.makedirs(output_dir, exist_ok=True)

    print_output_file = os.path.join(os.path.abspath(output_dir), output_filename)
    if os.path.exists(print_output_file):
        os.remove(print_output_file)

    xvfb_kwargs = {'width': args.rec_width, 'height': args.rec_height, 'colordepth': 24, }

    with recorded_xvfb(output_dir if record else None, 'pcbnew_print_layers_screencast.ogv', **xvfb_kwargs):
        with PopenContext(['pcbnew', pcb_file], stderr=subprocess.DEVNULL, close_fds=True) as pcbnew_proc:

            clipboard_store(print_output_file)

            wait_for_pcbnew()

            logger.info('Open File->Print')
            xdotool(['key', 'alt+f', 'p'])

            id = wait_for_window('Print dialog', 'Print')
            # The color option is selected (not with a WM)
            xdotool(['key', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Return'])

            id2 = wait_for_window('Printer dialog', '^(Print|%s)$' % print_dlg_name, skip_id=id[0])
            # List of printers
            xdotool(['key', 'Tab',
                     # Go up to the top
                     'Home',
                     # Output file name
                     'Tab',
                     # Open dialog
                     'Return'])
            id_sel_f = wait_for_window('Select a filename', '(Select a filename|%s)' % select_a_filename, 2)
            logger.info('Pasting output dir')
            xdotool(['key',
                     # Select all
                     'ctrl+a',
                     # Paste
                     'ctrl+v',
                     # Select this name
                     'Return'])
            # Back to print
            wait_not_focused(id_sel_f[0])
            wait_for_window('Printer dialog', '^(Print|%s)$' % print_dlg_name, skip_id=id[0])
            xdotool(['key',
                     # Format options
                     'Tab',
                     # Be sure we are at left (PDF)
                     'Left', 'Left', 'Left',
                     # Print it
                     'Return'])

            file_util.wait_for_file_created_by_process(pcbnew_proc.pid, print_output_file)

            wait_not_focused(id2[1])
            id = wait_for_window('Print dialog', 'Print')
            # Close button
            xdotool(['key', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Return'])

            wait_not_focused(id2[0])
            wait_for_window('Main pcbnew window', 'Pcbnew')
            pcbnew_proc.terminate()

    return print_output_file


def run_drc(pcb_file, output_dir, record=True, save=False):

    os.makedirs(output_dir, exist_ok=True)

    drc_output_file = os.path.join(os.path.abspath(output_dir), args.output_name[0])
    if os.path.exists(drc_output_file):
        os.remove(drc_output_file)

    xvfb_kwargs = {'width': args.rec_width, 'height': args.rec_height, 'colordepth': 24, }

    with recorded_xvfb(output_dir if record else None, 'pcbnew_run_drc_screencast.ogv', **xvfb_kwargs):
        with PopenContext(['pcbnew', pcb_file], stderr=subprocess.DEVNULL, close_fds=True) as pcbnew_proc:

            clipboard_store(drc_output_file)

            wait_for_pcbnew()

            logger.info('Open Inspect->DRC')
            xdotool(['key', 'alt+i', 'd'])

            wait_for_window('DRC modal window', 'DRC Control')
            # Note: Refill zones on DRC gets saved in ~/.config/kicad/pcbnew as RefillZonesBeforeDrc
            # The space here is to enable the report of all errors for tracks
            logger.info('Enable reporting all errors for tracks')
            xdotool(['key', 'Tab', 'Tab', 'Tab', 'Tab', 'space', 'Tab', 'Tab', 'Tab', 'Tab'])
            logger.info('Pasting output dir')
            xdotool(['key', 'ctrl+v', 'Return'])

            wait_for_window('Report completed dialog', 'Disk File Report Completed')
            xdotool(['key', 'Return'])

            if save:
                xdotool(['key', 'Escape'])
                wait_for_window('Main pcbnew window', 'Pcbnew')
                logger.info('Saving PCB')
                os.rename(pcb_file, pcb_file + '-bak')
                xdotool(['key', 'ctrl+s'])
                file_util.wait_for_file_created_by_process(pcbnew_proc.pid, os.path.realpath(pcb_file))

            pcbnew_proc.terminate()

    return drc_output_file


def load_layers(kicad_pcb_file):
    layer_names = ['-']*50
    pcb_file = open(kicad_pcb_file, "r")
    collect_layers = False
    for line in pcb_file:
        if collect_layers:
            z = re.match(r'\s+\((\d+)\s+(\S+)', line)
            if z:
                res = z.groups()
                # print(res[1]+'->'+res[0])
                layer_names[int(res[0])] = res[1]
            else:
                if re.search(r'^\s+\)$', line):
                    collect_layers = False
                    break
        else:
            if re.search(r'\s+\(layers', line):
                collect_layers = True
    pcb_file.close()
    return layer_names


class ListLayers(argparse.Action):
    """A special action class to list the PCB layers and exit"""
    def __call__(self, parser, namespace, values, option_string):
        layer_names = load_layers(values[0])
        for layer in layer_names:
            if layer != '-':
                print(layer)
        parser.exit()  # exits the program with no more arg parsing and checking


# Restore the pcbnew configuration
def restore_config():
    if os.path.exists(old_config_file):
        os.remove(config_file)
        os.rename(old_config_file, config_file)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='KiCad PCB automation')
    subparsers = parser.add_subparsers(help='Command:', dest='command')

    parser.add_argument('--record', '-r', help='Record the UI automation', action='store_true')
    parser.add_argument('--rec_width', help='Record width ['+str(REC_W)+']', type=int, default=REC_W)
    parser.add_argument('--rec_height', help='Record height ['+str(REC_H)+']', type=int, default=REC_H)
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--version', '-V', action='version', version='%(prog)s '+__version__+' - ' +
                        __copyright__+' - License: '+__license__)
    parser.add_argument('--wait_start', help='Timeout to pcbnew start ['+str(WAIT_START)+']', type=int, default=WAIT_START)

    export_parser = subparsers.add_parser('export', help='Export PCB layers')
    export_parser.add_argument('--list', '-l', help='Print a list of layers in LIST PCB and exit', nargs=1, action=ListLayers)
    export_parser.add_argument('--output_name', '-o', nargs=1, help='Name of the output file', default=['printed.pdf'])
    export_parser.add_argument('kicad_pcb_file', help='KiCad PCB file')
    export_parser.add_argument('output_dir', help='Output directory')
    export_parser.add_argument('layers', nargs='+', help='Which layers to include')

    drc_parser = subparsers.add_parser('run_drc', help='Run Design Rules Checker on a PCB')
    drc_parser.add_argument('--ignore_unconnected', '-i', help='Ignore unconnected paths', action='store_true')
    drc_parser.add_argument('--output_name', '-o', nargs=1, help='Name of the output file', default=['drc_result.rpt'])
    drc_parser.add_argument('--save', '-s', help='Save after DRC (updating filled zones)', action='store_true')
    drc_parser.add_argument('kicad_pcb_file', help='KiCad PCB file')
    drc_parser.add_argument('output_dir', help='Output directory')

    args = parser.parse_args()

    # Create a logger with the specified verbosity
    logger = log.init(args.verbose)

    # Get local versions for the GTK window names
    gettext.textdomain('gtk30')
    select_a_filename = gettext.gettext('Select a filename')
    print_dlg_name = gettext.gettext('Print')
    logger.debug('Select a filename -> '+select_a_filename)
    logger.debug('Print -> '+print_dlg_name)

    # Force english + UTF-8
    os.environ['LANG'] = 'C.UTF-8'

    # Check the file exists
    if not os.path.isfile(args.kicad_pcb_file):
        logger.error(args.kicad_pcb_file+' does not exist')
        exit(NO_PCB)

    # If we pass a name without extension KiCad will try to create a ".kicad_pcb"
    if os.path.splitext(args.kicad_pcb_file)[1] == '':
        logger.error('PCB files must use kicad_pcb extension')
        exit(WRONG_PCB_NAME)

    if args.command == 'export':
        # Read the layer names from the PCB
        layer_names = load_layers(args.kicad_pcb_file)

    # Back-up the current pcbnew configuration
    kicad_cfg_dir = os.path.join(os.environ['HOME'], '.config/kicad')
    if not os.path.isdir(kicad_cfg_dir):
        logger.debug('Creating KiCad config dir')
        os.makedirs(kicad_cfg_dir, exist_ok=True)
    config_file = os.path.join(kicad_cfg_dir, 'pcbnew')
    old_config_file = config_file + '.pre_script'
    logger.debug('PCBnew config: '+config_file)
    # If we have an old back-up ask for the user to solve it
    if os.path.isfile(old_config_file):
        logger.error('PCBnew config back-up found (%s)', old_config_file)
        logger.error('It could contain your pcbnew configuration, rename it to %s or discard it.', config_file)
        exit(PCBNEW_CFG_PRESENT)
    if os.path.isfile(config_file):
        logger.debug('Moving current config to '+old_config_file)
        os.rename(config_file, old_config_file)
        atexit.register(restore_config)

    # Create a suitable configuration
    text_file = open(config_file, "w")
    text_file.write('canvas_type=2\n')
    text_file.write('RefillZonesBeforeDrc=1\n')
    text_file.write('PcbFrameFirstRunShown=1\n')
    text_file.write('DrcTrackToZoneTest=1\n')
    if args.command == 'export':
        # Color
        text_file.write('PrintMonochrome=0\n')
        # Include frame
        text_file.write('PrintPageFrame=1\n')
        # Real drill marks
        text_file.write('PrintPadsDrillOpt=2\n')
        # Only one file
        text_file.write('PrintSinglePage=1\n')
        # Mark which layers are requested
        used_layers = [0]*50
        for layer in args.layers:
            try:
                # Support for kiplot inner layers
                if layer.startswith("Inner"):
                    m = re.match(r"^Inner\.([0-9]+)$", layer)
                    if not m:
                        logger.error('Malformed inner layer name: '+layer+', use Inner.N')
                        sys.exit(WRONG_LAYER_NAME)
                    layer_n = int(m.group(1))
                    if layer_n > 49 or layer_names[layer_n] == '-':
                        logger.error(layer+" isn't a valid layer")
                        sys.exit(WRONG_LAYER_NAME)
                    used_layers[layer_n] = 1
                else:
                    used_layers[layer_names.index(layer)] = 1
            except ValueError:
                logger.error('Unknown layer '+layer)
                sys.exit(WRONG_LAYER_NAME)
        # List all posible layers, indicating which ones are requested
        for x in range(0, 50):
            text_file.write('PlotLayer_%d=%d\n' % (x, used_layers[x]))
    text_file.close()

    # Make sure the user has fp-lib-table
    user_lib_table = os.path.join(kicad_cfg_dir, 'fp-lib-table')
    if not os.path.isfile(user_lib_table):
        logger.debug('Missing default fp-lib-table')
        system_lib_table = '/usr/share/kicad/template/fp-lib-table'
        if os.path.isfile(system_lib_table):
            shutil.copy2(system_lib_table, user_lib_table)
        else:
            logger.warning('Missing default system footprint table '+system_lib_table+' KiCad will most probably fail')

    error_level = 0
    if args.command == 'export':
        print_layers(args.kicad_pcb_file, args.output_dir, args.output_name[0], args.record)
    else:  # run_drc
        drc_errors, unconnected_pads = parse_drc(run_drc(args.kicad_pcb_file, args.output_dir, args.record, args.save))
        logger.debug('Found {} DRC errors and {} unconnected pads'.format(drc_errors, unconnected_pads))

        if drc_errors == 0 and unconnected_pads == 0:
            logger.info('No errors')
        else:
            logger.error('Found {} DRC errors and {} unconnected pads'.format(drc_errors, unconnected_pads))
            if args.ignore_unconnected:
                unconnected_pads = 0
            error_level = -(drc_errors+unconnected_pads)

    # The following code is here only to make coverage tool properly meassure atexit code.
    atexit.unregister(restore_config)
    restore_config()
    exit(error_level)
