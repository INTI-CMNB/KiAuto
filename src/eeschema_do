#!/usr/bin/env python3
"""Various schematic operations

This program runs eeschema and can:
1) Export (plot) the schematic
2) Generate the netlist
3) Generate the BoM in XML format
4) Run the ERC
The process is graphical and very delicated.
"""

__author__ = 'Scott Bezek, Salvador E. Tropea'
__copyright__ = 'Copyright 2015-2020, INTI/Productize SPRL/Scott Bezek'
__credits__ = ['Salvador E. Tropea', 'Scott Bezek']
__license__ = 'Apache 2.0'
__email__ = 'salvador@inti.gob.ar'
__status__ = 'beta'

import os
import subprocess
import sys
import re
import argparse
import atexit
import shutil

# Look for the 'kicad_auto' module from where the script is running
script_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, os.path.dirname(script_dir))
# kicad_auto import
# Log functionality first
from kicad_auto import log
log.set_domain(os.path.splitext(os.path.basename(__file__))[0])
from kicad_auto import file_util
from kicad_auto.misc import (REC_W, REC_H, __version__, NO_SCHEMATIC, EESCHEMA_CFG_PRESENT, KICAD_CFG_PRESENT, WAIT_START)
from kicad_auto.ui_automation import (
    PopenContext,
    xdotool,
    wait_for_window,
    wait_not_focused,
    recorded_xvfb,
    clipboard_store
)


# def dismiss_library_error():
#     # The "Error" modal pops up if libraries required by the schematic have
#     # not been found. This can be ignored as all symbols are placed inside the
#     # *-cache.lib file:
#     # There -should- be a way to disable it, but I haven't the magic to drop in the config file yet
#     try:
#         nf_title = 'Error'
#         wait_for_window(nf_title, nf_title, 3)
#
#         logger.info('Dismiss eeschema library warning modal')
#         xdotool(['search', '--onlyvisible', '--name', nf_title, 'windowfocus'])
#         xdotool(['key', 'Escape'])
#     except RuntimeError:
#         pass


# def dismiss_library_warning():
#     # The "Not Found" window pops up if libraries required by the schematic have
#     # not been found. This can be ignored as all symbols are placed inside the
#     # *-cache.lib file:
#     try:
#         nf_title = 'Not Found'
#         wait_for_window(nf_title, nf_title, 3)
#
#         logger.info('Dismiss eeschema library warning window')
#         xdotool(['search', '--onlyvisible', '--name', nf_title, 'windowfocus'])
#         xdotool(['key', 'Return'])
#     except RuntimeError:
#         pass


# def dismiss_newer_version():
#     # The "Not Found" window pops up if libraries required by the schematic have
#     # not been found. This can be ignored as all symbols are placed inside the
#     # *-cache.lib file:
#     try:
#         logger.info('Dismiss schematic version notification')
#         wait_for_window('Newer schematic version notification', 'Info', 3)
#
#         xdotool(['key', 'Return'])
#     except RuntimeError:
#         pass


# def dismiss_remap_helper():
#     # The "Remap Symbols" windows pop up if the uses the project symbol library
#     # the older list look up method for loading library symbols.
#     # This can be ignored as we're just trying to output data and don't
#     # want to mess with the actual project.
#     try:
#         logger.info('Dismiss schematic symbol remapping')
#         wait_for_window('Remap Symbols', 'Remap', 3)
#
#         xdotool(['key', 'Escape'])
#     except RuntimeError:
#         pass


def eeschema_skip_errors():
    # dismiss_newer_version()
    # dismiss_remap_helper();
    # dismiss_library_warning()
    # dismiss_library_error()
    return 0


def wait_eeschema(time):
    return wait_for_window('Main eeschema window', r'Eeschema.*\.sch', time)


def wait_eeschema_start():
    failed_focuse = False
    try:
        wait_eeschema(args.wait_start)
    except RuntimeError:
        failed_focuse = True
        pass
    if failed_focuse:
        eeschema_skip_errors()
        wait_eeschema(5)


def eeschema_plot_schematic(output_dir, output_file, all_pages, pid, ext):
    clipboard_store(output_dir)

    wait_eeschema_start()

    logger.info('Open File->pLot')
    xdotool(['key', 'alt+f', 'l'])

    wait_for_window('plot', 'Plot')

    logger.info('Paste output directory')
    xdotool(['key', 'ctrl+v'])

    logger.info('Move to the "plot" button')
    # We try to select the "print all" button.
    # Lamentably this is the default, so we can be confused because "Return" will press it anyways.
    command_list = ['key', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab',
                    'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', ]
    if ext == 'dxf':
        # DXF greys one widget (net result)
        command_list.pop()
    if ext == 'plt':
        # HPGL enables one widget (net result)
        command_list.append('Tab')
    if not all_pages:
        # If "print all" is selected one more tab is "print current"
        command_list.append('Tab')
    logger.debug(str(command_list)+'   '+str(len(command_list)))
    xdotool(command_list)

    logger.info('Plot')
    xdotool(['key', 'Return'])

    logger.info('Wait for plot file creation')
    file_util.wait_for_file_created_by_process(pid, output_file)

    logger.info('Closing window')
    xdotool(['key', 'Escape'])

    # Wait until the dialog is closed, useful when more than one file are created
    id = wait_eeschema(10)

    logger.info('Exiting eeschema')
    xdotool(['key', 'ctrl+q'])
    try:
        wait_not_focused(id[0], 5)
    except RuntimeError:
        logger.debug('EEschema not exiting, will retry')
        pass
    # Dismiss any dialog. I.e. failed to write the project
    xdotool(['key', 'Return', 'ctrl+q'])
    try:
        wait_not_focused(id[0], 5)
    except RuntimeError:
        logger.debug('EEschema not exiting, will kill')
        pass
    # If we failed to exit we will kill it anyways


def eeschema_parse_erc(erc_file, warning_as_error=False):
    with open(erc_file, 'r') as f:
        lines = f.read().splitlines()
        last_line = lines[-1]

    logger.debug('Last line: '+last_line)
    m = re.search(r'^ \*\* ERC messages: ([0-9]+) +Errors ([0-9]+) +Warnings ([0-9]+)+$', last_line)
    # messages = m.group(1)
    errors = m.group(2)
    warnings = m.group(3)

    if warning_as_error:
        return int(errors) + int(warnings), 0
    return int(errors), int(warnings)


def eeschema_run_erc_schematic(erc_file, pid):
    # Do this now since we have to wait for KiCad anyway
    clipboard_store(erc_file)

    wait_eeschema_start()

    logger.info('Open Tools->Electrical Rules Checker')
    xdotool(['key', 'alt+i', 'c'])

    wait_for_window('Electrical Rules Checker dialog', 'Electrical Rules Checker')
    xdotool(['key', 'Tab', 'Tab', 'Tab', 'Tab', 'space', 'Return'])

    wait_for_window('ERC File save dialog', 'ERC File')
    logger.info('Pasting output file')
    xdotool(['key', 'ctrl+v'])
    # KiCad adds .erc
    erc_file = erc_file + '.erc'
    if os.path.exists(erc_file):
        os.remove(erc_file)

    logger.info('Run ERC')
    xdotool(['key', 'Return'])

    logger.info('Wait for ERC file creation')
    file_util.wait_for_file_created_by_process(pid, erc_file)

    logger.info('Exit ERC')
    xdotool(['key', 'shift+Tab', 'Return'])

    return erc_file


def eeschema_netlist_commands(net_file, pid):
    # Do this now since we have to wait for KiCad anyway
    clipboard_store(net_file)

    wait_eeschema_start()

    logger.info('Open Tools->Generate Netlist File')
    xdotool(['key', 'alt+t', 'n'])

    wait_for_window('Netlist dialog', 'Netlist')
    xdotool(['key', 'Tab', 'Tab', 'Return'])

    wait_for_window('Netlist File save dialog', 'Save Netlist File')
    logger.info('Pasting output file')
    xdotool(['key', 'ctrl+v'])
    # KiCad adds .net
    net_file = net_file + '.net'
    if os.path.exists(net_file):
        os.remove(net_file)

    logger.info('Generate Netlist')
    xdotool(['key', 'Return'])

    logger.info('Wait for Netlist file creation')
    file_util.wait_for_file_created_by_process(pid, net_file)

    return net_file


def eeschema_bom_xml_commands(output_file, pid):
    clipboard_store('xsltproc -o "'+output_file + '" "/usr/share/kicad/plugins/bom2grouped_csv.xsl" "%I"')

    wait_eeschema_start()

    logger.info('Open Tools->Generate Bill of Materials')
    xdotool(['key', 'alt+t', 'm'])

    wait_for_window('Bill of Material dialog', 'Bill of Material')
    logger.info('Paste xslt command')
    xdotool(['key', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'Tab', 'ctrl+v', 'Return'])

    logger.info('Wait for BoM file creation')
    file_util.wait_for_file_created_by_process(pid, output_file)


# Restore the eeschema configuration
def restore_config():
    if os.path.exists(old_config_file):
        os.remove(config_file)
        os.rename(old_config_file, config_file)
        logger.debug('Restoring old eeschema config')


# Restore the KiCad common configuration
def restore_common_config():
    if os.path.exists(old_common_config_file):
        os.remove(common_config_file)
        os.rename(old_common_config_file, common_config_file)
        logger.debug('Restoring old KiCad common config')


# Variables used to memorize .pro state
pro_name = None
pro_stat = None
pro_content = None


def memorize_project(sch):
    """ Detect the .pro filename and try to read it and its mtime.
        If KiCad changes it then will try to revert the changes """
    global pro_name
    global pro_stat
    global pro_content
    pro_name = os.path.splitext(sch)[0]+'.pro'
    if not os.path.isfile(pro_name):
        logger.warning('KiCad project file not found')
        return
    pro_stat = os.stat(pro_name)
    with open(pro_name) as f:
        pro_content = f.read()
    atexit.register(restore_project)


def restore_project():
    """ If the .pro was modified try to restore it """
    logger.debug('Checking if .pro was modified')
    if pro_stat and pro_content:
        pro_found = False
        if os.path.isfile(pro_name):
            new_stat = os.stat(pro_name)
            pro_found = True
        else:
            logger.warning('Project file lost')
        if not pro_found or new_stat.st_mtime != pro_stat.st_mtime:
            logger.debug('Restoring the project file')
            os.rename(pro_name, pro_name+'-bak')
            with open(pro_name, 'w') as f:
                f.write(pro_content)
            os.utime(pro_name, times=(pro_stat.st_atime, pro_stat.st_mtime))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='KiCad schematic automation')
    subparsers = parser.add_subparsers(help='Command:', dest='command')

    parser.add_argument('schematic', help='KiCad schematic file')
    parser.add_argument('output_dir', help='Output directory')

    parser.add_argument('--record', '-r', help='Record the UI automation', action='store_true')
    parser.add_argument('--rec_width', help='Record width ['+str(REC_W)+']', type=int, default=REC_W)
    parser.add_argument('--rec_height', help='Record height ['+str(REC_H)+']', type=int, default=REC_H)
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--version', '-V', action='version', version='%(prog)s '+__version__+' - ' +
                        __copyright__+' - License: '+__license__)
    parser.add_argument('--wait_start', help='Timeout to pcbnew start ['+str(WAIT_START)+']', type=int, default=WAIT_START)

    export_parser = subparsers.add_parser('export', help='Export a schematic')
    export_parser.add_argument('--file_format', '-f', help='Export file format',
                               choices=['svg', 'pdf', 'ps', 'dxf', 'hpgl'], default='pdf')
    export_parser.add_argument('--all_pages', '-a', help='Plot all schematic pages in one file', action='store_true')

    erc_parser = subparsers.add_parser('run_erc', help='Run Electrical Rules Checker on a schematic')
    erc_parser.add_argument('--warnings_as_errors', '-w', help='Treat warnings as errors', action='store_true')

    netlist_parser = subparsers.add_parser('netlist', help='Create the netlist')
    bom_xml_parser = subparsers.add_parser('bom_xml', help='Create the BoM in XML format')

    args = parser.parse_args()

    # Create a logger with the specified verbosity
    logger = log.init(args.verbose)

    if not os.path.isfile(args.schematic):
        logger.error(args.schematic+' does not exist')
        exit(NO_SCHEMATIC)

    memorize_project(args.schematic)

    # Create output dir if it doesn't exist
    output_dir = os.path.abspath(args.output_dir)+'/'
    os.makedirs(output_dir, exist_ok=True)

    # Force english + UTF-8
    os.environ['LANG'] = 'C.UTF-8'

    # Back-up the current eeschema configuration
    kicad_cfg_dir = os.path.join(os.environ['HOME'], '.config/kicad')
    if not os.path.isdir(kicad_cfg_dir):
        logger.debug('Creating KiCad config dir')
        os.makedirs(kicad_cfg_dir, exist_ok=True)
    config_file = os.path.join(kicad_cfg_dir, 'eeschema')
    old_config_file = config_file + '.pre_script'
    logger.debug('Eeschema config: '+config_file)
    # If we have an old back-up ask for the user to solve it
    if os.path.isfile(old_config_file):
        logger.error('Eeschema config back-up found (%s)', old_config_file)
        logger.error('It could contain your eeschema configuration, rename it to %s or discard it.', config_file)
        exit(EESCHEMA_CFG_PRESENT)
    if os.path.isfile(config_file):
        logger.debug('Moving current config to '+old_config_file)
        os.rename(config_file, old_config_file)
        atexit.register(restore_config)

    # Create a suitable configuration
    logger.debug('Creating an eeschema config')
    text_file = open(config_file, "w")
    text_file.write('RescueNeverShow=1\n')
    if args.command == 'export':
        # HPGL:0 ??:1 PS:2 DXF:3 PDF:4 SVG:5
        index = ['hpgl', '---', 'ps', 'dxf', 'pdf', 'svg'].index(args.file_format.lower())
        logger.debug('Selecting plot format %s (%d)', args.file_format, index)
        text_file.write('PlotFormat=%d\n' % index)
    text_file.close()

    # Back-up the current kicad_common configuration
    common_config_file = os.environ['HOME'] + '/.config/kicad/kicad_common'
    old_common_config_file = common_config_file + '.pre_script'
    logger.debug('Kicad common config: '+common_config_file)
    # If we have an old back-up ask for the user to solve it
    if os.path.isfile(old_common_config_file):
        logger.error('KiCad common config back-up found (%s)', old_common_config_file)
        logger.error('It could contain your kiCad configuration, rename it to %s or discard it.', common_config_file)
        exit(KICAD_CFG_PRESENT)
    if os.path.isfile(common_config_file):
        logger.debug('Moving current config to '+old_common_config_file)
        os.rename(common_config_file, old_common_config_file)
        atexit.register(restore_common_config)

    # Create a suitable configuration
    logger.debug('Creating a KiCad common config')
    text_file = open(common_config_file, "w")
    text_file.write('ShowEnvVarWarningDialog=0\n')
    text_file.write('Editor=/bin/cat\n')
    text_file.close()

    # Make sure the user has sym-lib-table
    user_lib_table = os.path.join(kicad_cfg_dir, 'sym-lib-table')
    if not os.path.isfile(user_lib_table):
        logger.debug('Missing default sym-lib-table')
        system_lib_table = '/usr/share/kicad/template/sym-lib-table'
        if os.path.isfile(system_lib_table):
            shutil.copy2(system_lib_table, user_lib_table)
        else:
            logger.warning('Missing default system symbol table '+system_lib_table+' KiCad will most probably fail')

    output_file_no_ext = os.path.join(output_dir, os.path.splitext(os.path.basename(args.schematic))[0])
    with recorded_xvfb(output_dir if args.record else None, args.command+'_eeschema_screencast.ogv',
                       width=args.rec_width, height=args.rec_height, colordepth=24):
        with PopenContext(['eeschema', args.schematic], close_fds=True,
                          stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL) as eeschema_proc:
            if args.command == 'export':
                # Export
                ext = args.file_format.lower()
                if ext == 'hpgl':
                    ext = 'plt'
                output_file = output_file_no_ext+'.'+ext
                if os.path.exists(output_file):
                    logger.debug('Removing old file')
                    os.remove(output_file)
                eeschema_plot_schematic(output_dir, output_file, args.all_pages, eeschema_proc.pid, ext)
            elif args.command == 'netlist':
                # Netlist
                eeschema_netlist_commands(output_file_no_ext, eeschema_proc.pid)
            elif args.command == 'bom_xml':
                # BoM XML
                output_file = output_file_no_ext+'.csv'
                eeschema_bom_xml_commands(output_file, eeschema_proc.pid)
            elif args.command == 'run_erc':
                # Run ERC
                erc_file = eeschema_run_erc_schematic(output_file_no_ext, eeschema_proc.pid)
                errors, warnings = eeschema_parse_erc(erc_file, args.warnings_as_errors)
                if warnings > 0:
                    logger.warning(str(warnings)+' ERC warnings detected')
                if errors > 0:
                    logger.error(str(errors)+' ERC errors detected')
                    exit(-errors)
                logger.info('No errors')
            eeschema_proc.terminate()
    # The following code is here only to make coverage tool properly meassure atexit code.
    atexit.unregister(restore_project)
    restore_project()
    atexit.unregister(restore_config)
    restore_config()
    atexit.unregister(restore_common_config)
    restore_common_config()
    exit(0)
